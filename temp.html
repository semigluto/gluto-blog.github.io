/* This is a 3D wandering scene made using old version opengl (glut)
 * The scene includes: a orange block, a wall (with detection of if the mouse is inside it), and a box with error rendering
 */

/* To compile this, use gcc wandering_test.c -lGL -lGLU -lglfw
 * Make sure you installed opengl (glut, with all it's lib compiled) already
 */

#define GLUT_DISABLE_ATEXIT_HACK
#define _USE_MATH_DEFINES
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>
#include <stdio.h>

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

#include <stdio.h>
#include <stdbool.h>


#define SCREEN_SIZE 40
#define convert_rgb(x) x/256.0
#define PI 3.1415926
#define TOR PI/180


void display();
void reshape(int,int);
void keyboard(unsigned char,int,int);
void move(int,int);
void timer(int);
void init();

unsigned int tim=0;

float lr_angle=0,ud_angle=0;
int screen_x,screen_y;
float center_x=0,center_y=2,center_z=5;
double look_x_temp,look_z_temp;
long double reduce=1,look_x=0,look_y=0,look_z=-1;

double z0_pos_x;
double z0_pos_y;

unsigned int textureID;
int width,height,nrChannels;
unsigned char *data;

int main(int argc,char **argv)
{
	glutInit(&argc,argv);
	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
	glutInitWindowPosition(0,0);
	glutInitWindowSize(1980,1080);
	glutCreateWindow("title");
	glutFullScreen(); 
	
	glutDisplayFunc(display);
	glutIdleFunc(display);
	glutReshapeFunc(reshape);
	glutKeyboardFunc(keyboard);
	glutTimerFunc(0,timer,0);
	glutPassiveMotionFunc(move);
	init();
	
	glutMainLoop();//in loop
	return 0;
}

void display(){
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);//clear
	glLoadIdentity();

	gluLookAt(center_x,center_y,center_z,center_x+look_x,center_y+look_y,center_z+look_z,0,1,0);
	
	glBegin(GL_QUADS);
	glColor3f(0.5,0.5,0.5);
	glVertex3f(20.0,-1.0,-20.0);
	glVertex3f(20.0,-1.0,20.0);
	glVertex3f(-20.0,-1.0,20.0);
	glVertex3f(-20,-1.0,-20.0);
	glEnd();

	glTranslatef(0,2,0);

	glBegin(GL_QUADS);
	if (z0_pos_x>-1.0&&z0_pos_x<1.0&&z0_pos_y>-1.0+2.0&&z0_pos_y<1.0+2.0) glColor3f(0.0,1.0,0.0);
	else glColor3f(1.0,0.0,0.0);
	glVertex3f(-1.0,1.0,0.0);
	glVertex3f(1.0,1.0,0.0);
	glVertex3d(1.0,-1.0,0.0);
	glVertex3f(-1.0,-1.0,0.0);
	glEnd();

	glTranslatef(5,-2,0);
	 
	glBegin(GL_QUADS);
        glColor3f(1.0,0.5,0.0);
        glVertex3f(-1.0,1.0,1.0);
    	glVertex3f(-1.0,-1.0,1.0);
    	glVertex3f(1.0,-1.0,1.0);
    	glVertex3f(1.0,1.0,1.0);
    	glVertex3f(1.0,1.0,-1.0);
    	glVertex3f(1.0,-1.0,-1.0);
    	glVertex3f(-1.0,-1.0,-1.0);
    	glVertex3f(-1.0,1.0,-1.0);
    	glVertex3f(1.0,1.0,1.0);
    	glVertex3f(1.0,-1.0,1.0);
    	glVertex3f(1.0,-1.0,-1.0);
    	glVertex3f(1.0,1.0,-1.0);
    	glVertex3f(-1.0,1.0,-1.0);
    	glVertex3f(-1.0,-1.0,-1.0);
    	glVertex3f(-1.0,-1.0,1.0);
    	glVertex3f(-1.0,1.0,1.0);
    	glVertex3f(-1.0,1.0,-1.0);
    	glVertex3f(-1.0,1.0,1.0);
    	glVertex3f(1.0,1.0,1.0);
    	glVertex3f(1.0,1.0,-1.0);
    	glVertex3f(-1.0,-1.0,-1.0);
    	glVertex3f(-1.0,-1.0,1.0);
    	glVertex3f(1.0,-1.0,1.0);
    	glVertex3f(1.0,-1.0,-1.0);
	glEnd();

	glLineWidth(3);
	glBegin(GL_LINES);
	glColor3f(0.0,0.0,0.0);
	glVertex3f(-1.0,1.0,1.0);
	glVertex3f(1.0,1.0,1.0);
	glVertex3f(1.0,1.0,1.0);
	glVertex3f(1.0,-1.0,1.0);
	glVertex3f(1.0,-1.0,1.0);
	glVertex3f(-1.0,-1.0,1.0);
	glVertex3f(-1.0,-1.0,1.0);
	glVertex3f(-1.0,1.0,1.0);
	glVertex3f(-1.0,1.0,-1.0);
	glVertex3f(1.0,1.0,-1.0);
	glVertex3f(1.0,1.0,-1.0);
	glVertex3f(1.0,-1.0,-1.0);
	glVertex3f(1.0,-1.0,-1.0);
	glVertex3f(-1.0,-1.0,-1.0);
	glVertex3f(-1.0,-1.0,-1.0);
	glVertex3f(-1.0,1.0,-1.0);
	glVertex3f(-1.0,1.0,1.0);
	glVertex3f(-1.0,1.0,-1.0);
	glVertex3f(1.0,1.0,1.0);
	glVertex3f(1.0,1.0,-1.0);
	glVertex3f(1.0,-1.0,1.0);
	glVertex3f(1.0,-1.0,-1.0);
	glVertex3f(-1.0,-1.0,1.0);
	glVertex3f(-1.0,-1.0,-1.0);
	glEnd();

	glTranslatef(5,0,0);
	glEnable(GL_TEXTURE_2D);
	glBegin(GL_QUADS);
	glTexCoord2f(0.0, 0.0); glVertex3f(-1.0, 1.0, 1.0);
    	glTexCoord2f(1.0, 0.0); glVertex3f(1.0, 1.0, 1.0);
    	glTexCoord2f(1.0, 1.0); glVertex3f(1.0, -1.0, 1.0);
    	glTexCoord2f(0.0, 1.0); glVertex3f(-1.0, -1.0, 1.0);
	glEnd();
	glDisable(GL_TEXTURE_2D);
	
	glColor3f(1.0,1.0,1.0);
	glRasterPos3f(-3,2,0);
	
	void *font=GLUT_BITMAP_TIMES_ROMAN_24;
	const char *str="Experimental_Lab";
	while (*str){
		glutBitmapCharacter(font,*str);
		str++;
	}

	
	// 禁用深度测试，以确保准星位于最前面
    	glDisable(GL_DEPTH_TEST);
    	glColor3f(1.0f, 1.0f, 1.0f);
    	// 保存当前的变换矩阵
    	glPushMatrix();
    	// 将投影模式设置为正交投影
    	glMatrixMode(GL_PROJECTION);
    	glPushMatrix();
    	glLoadIdentity();
    	gluOrtho2D(-990,990,-540,540);

    	// 切换回模型视图矩阵
    	glMatrixMode(GL_MODELVIEW);
    	glLoadIdentity();

    	// 绘制准星
    	glBegin(GL_QUADS);
        glVertex2f(-3,-3);
        glVertex2f(3,-3);
        glVertex2f(3,3);
        glVertex2f(-3,3);
   	glEnd();

   	// 恢复之前的投影矩阵
   	glMatrixMode(GL_PROJECTION);
   	glPopMatrix();

   	// 恢复之前的模型视图矩阵
   	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();

    	// 重新启用深度测试
    	glEnable(GL_DEPTH_TEST);

	glutSwapBuffers();
}

void reshape(int w,int h){
	glViewport(0,0,w,h);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(75,16.0/9.0,1,30);
	glMatrixMode(GL_MODELVIEW);
}

void keyboard(unsigned char key, int x, int y){
	if (key=='q') exit(0);

	float fab_z=cos(TOR*lr_angle)*0.1;
	float fab_x=sin(TOR*lr_angle)*0.1;

	if (key=='w'){center_x+=fab_x;center_z-=fab_z;}
	if (key=='s'){center_x-=fab_x;center_z+=fab_z;}
	if (key=='a'){center_x-=fab_z;center_z-=fab_x;}
	if (key=='d'){center_x+=fab_z;center_z+=fab_x;}	
}

void move(int x,int y){
	screen_x=x-(1980/2);
	screen_y=(1080/2)-y;
}

void timer(int time){
	glutPostRedisplay();
	glutTimerFunc(1000.0/60.0,timer,0);
	tim++;

	//motion
	lr_angle=screen_x*(360.0/1980.0);
	ud_angle=screen_y*(180.0/1080.0);

	look_x_temp=sin(TOR*lr_angle);
	look_z_temp=-cos(TOR*lr_angle);

	look_y=sin(TOR*ud_angle);
	reduce=cos(TOR*ud_angle);

	look_x=look_x_temp*reduce;
	look_z=look_z_temp*reduce;

	//projection on the z=0
	z0_pos_x=(tan(TOR*lr_angle)*center_z)+center_x;
	z0_pos_y=(tan(TOR*ud_angle)*((z0_pos_x-center_x)/sin(TOR*lr_angle)))+center_y;
	
	//log output
	if (tim%60==0){
		printf("time:%d",tim); 

		printf("screen_x:%d screen_y:%d\n",screen_x,screen_y);
		printf("lr_angle:%f ud_angle:%f\n",lr_angle,ud_angle);
		printf("look_x_temp:%f look_z_temp:%f\n",look_x_temp,look_z_temp);
		printf("look_y:%Lf reduce:%Lf\n",look_y,reduce);
		printf("look_x:%Lf look_z:%Lf\n",look_x,look_z);

		printf("z0_pos_x:%f z0_pos_y:%f\n",z0_pos_x,z0_pos_y);

		printf("\n");
	}

}

void init(){
	glClearColor(convert_rgb(113), convert_rgb(188), convert_rgb(225),1.0);
	glEnable(GL_DEPTH_TEST);

	glutSetCursor(GLUT_CURSOR_NONE);

	data=stbi_load("container.jpg",&width,&height,&nrChannels, 3);
	if (!data){
		printf("Failed to load the .jpg image\n");
		exit(0);
	}
	glGenTextures(1,&textureID);
	glBindTexture(GL_TEXTURE_2D, textureID);

	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);
}
